#### 什么是注解(Annotation)
从`JDK5.0`开始引进的技术.

作用:
- 非程序本身,可以对程序做出解释(这和注释类似).
- 可以被其他程序读取(如编译器等).

格式:
注解是以`@注释名`在程序中存在的,也可以加入一些参数值,例如`@SuppressWarnings(value="unchecked")`.

在哪使用:


#### 内置注解
`@Override`
定义于`java.lang.Override`
一般放在要重写的方法上,如果方法不是重写的,会报错.
用于声明表示将要重写一个超类中的方法,
```java
@Override
public String toString(){
	return super.toString();//所有类都继承于Object类
}
```

`@Deprecated`
定义于`java.lang.Deprecated`
用于声明该方法,属性,类不鼓励使用,因为可能比较危险,或者有更好的替代方法.在新版本`JDK`中已删去
```Java
@Deprecated
public void say(){
	System.out.println("Deprecated");
}
```

`@SuppressWarnings("all")`
定义于`java.lang.SuppressWarnings`
哪里都能放,类,方法,属性上边.
用于抑制编译时产生的警告信息,需要添加参数.
- `@SuppressWarnings("all")`
- `@SuppressWarnings("unchecked")`
- `@SuppressWarnings(value = "unchecked","deprecation")`
- 等等....


#### 元注解
自定义注解使用,负责注解其他注解,
`@Target`表示注解可以用在什么地方
`@Retention`表示注解还在什么地方有效
`@Document`表示是否将注解生成在`JAVAdoc`中
`@Inherited`表示子类可以继承父类的注解



#### 自定义注解
使用`@interface`自定义注解时,自动继承`java.lang.annotation.Annotation`接口


```Java
public class Annotations{  
    @MyAnnotation1(age = 18)//没有设定默认值时,需要在这里声明.
    public void test(){}  
    @MyAnnotation2(value = "0")  
    public void sau(){}  
}  
@Target({ElementType.TYPE,ElementType.METHOD})  
@Retention(RetentionPolicy.RUNTIME)  
@interface MyAnnotation1{  
    //注解的参数: 参数类型 + 参数名();如果赋默认值就加上default 默认值.  
    String name() default "";  
    int age();  
    int id() default -1;  
} 
@Target({ElementType.TYPE,ElementType.METHOD})  
@Retention(RetentionPolicy.RUNTIME)  
@interface MyAnnotation2{  
    String value();  //只有一个参数时可以直接使用value();
}
```

#### 什么是反射(Reflection)
反射可以编写能够动态操控Java代码的程序.
能够分析类能力的程序称为反射.

- 在运行时分析类的能力,
- 在运行时查看对象,
- 实现通用的数组操作代码,
- 利用`Method`对象,

反射主要用于工具构造;

#### `Class`类
程序运行时,Java运行时始终为所有的对象维护一个被称为运行时的类型标识.这个信息跟随者每个对象所属的类.虚拟机利用运行时类型信息选择相应的方法执行.

可以通过专门的`Java`类访问这些信息,这些信息被称为`Class`.`Object`类中的`getClass()`方法会返回一个`Class`类型实例.
```java
Employee e;
Class cl = e.getClass();
```
常用的Class方法为getName,此方法将返回类的名字.
```Java
System.out.println(e.getClass().getName() + " " + e.getName());
```




优点:

缺点:



