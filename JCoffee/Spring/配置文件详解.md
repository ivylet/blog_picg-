```xml
<bean id=" " class = "" scope=" " init-method=" " destroy-method=" "><\bean>
```
#### `Bean`标签基本配置

`id` Bean实例在`Spring`容器中的唯一标识  
`class` Bean的全限定名称

#### `Bean`标签的范围配置

`scope`:指对象的作用范围,取值如下:
`singleton` 默认值,单例的
`prototype` 多例的

`singleton` 默认值,单例的
`Bean`的实例化个数: 1
`Bean`的实例化时机: 当`Spring`核心文件被加载时,实例化配置的`Bean`实例
`Bean`的生命周期: 
1. 对象创建: 当应用加载,创建容器时,对象就被创建了.(应用初始化时创建)
2. 对象运行: 只要容器在,对象一直活着.
3. 对象销毁:当应用卸载,销毁容器时,对象就被销毁了.(与容器共存亡,容器创建,`Bean`创建,容器销毁,`Bean`销毁)

`prototype` 多例的
`Bean`的实例化个数: 多个
`Bean`的实例化时机: 当调用`getBean()`方法时实例化`Bean`
`Bean`的生命周期: 
1. 对象创建:当使用对象时,创建新的对象实例.(使用时创建)
2. 对象运行:只要对象在使用中,就一直活着.
3. 对象销毁:当对象长时间不用时,被`Java`的垃圾回收机制回收了.

#### `Bean`生命周期配置

`init-method`:指定类中的初始化方法名称
`destroy-method`:指定类中销毁方法名称

#### `Bean`实例化三种方式

- 无参*构造*方法实例化
- 工厂*静态*方法实例化
- 工厂*实例*方法实例化

无参构造方法实例化

工厂*静态*方法实例化
```xml
//XML文件配置
<bean id = "noCanCreate" class="com.taytay.factory.StaticFactory" factory-method="getUserDao"> </bean>
```
//StaticFactory.java配置
```java
public class StaticFactory {  
    public static UserDao getUserDao(){  
        return new UserDaoImpl();  
    }  
}
```


工厂*实例*方法实例化
//XML文件配置
```xml
<bean id="factory" class="com.taytay.factory.DynamicFactory"> </bean>  
<bean id="userDao" factory-bean="factory" factory-method="getUserDao"> </bean>
```
//DynamicFactory.java配置
```java
public class DynamicFactory {  
    public UserDao getUserDao(){  
        return new UserDaoImpl();  
    }  
}
```


#### `Bean`依赖注入
举例,因为`UserService`和`UserDao`都在`Spring`容器中,需要使用`UserService`类和`UserDao`的方法,可以在容器中将`UserDao`注入`UserService`,然后再获取`UserService`类进行使用.

不提供依赖注入时,是将`UserService`和`UserDao`在程序代码中进行组装,能否直接在`Spring`容器中就组装呢?因为实际操作的只有`UserService`.

提供依赖注入后,只需要获取`UserService`实例,再通过这个实例调用`UserDao`的方法.

依赖注入(`Dependency Injection`): 是`Spring`框架核心`IOC`的具体实现
降低耦合度,但并不是不需要耦合.主要是降低它们之间的依赖程度.

所以要怎么在容器中组装呢?

#### `Bean`依赖注入的注入方式
- 构造方法
- `set`方法

构造方法
```Java
public class UserServiceImpl implements UserService{
	private UserDao userDao;
	public void save(){  
	    userDao.save();  
	    System.out.println("save running");  
	}  
	public UserServiceImpl(UserDao userDao){  
	    this.userDao = userDao;  
	}  
	public UserServiceImpl(){  
  
	}

}	
```

```xml
<bean id="userService" class="com.service.impl.UserServiceImpl">   
    <constructor-arg name="userDao" ref="userDao"></constructor-arg>  
</bean>
```

`set`方法
```java
public class UserServiceImpl implements UserService{

	private UserDao userDao;
	public void setUserDao(UserDao userDao){
		this.userDao = userDao;
	}
	public void save(){
		userDao.save();//使用userDao的save方法;
	}
}
```

```xml
<bean id = "userDao" class = "com.dao.UserDaoImpl"> </bean>
<bean id = "userService" class = "com.service.UserServiceImpl">
	<property name = "userDao" ref = "userDao"> </property>
<\bean>
```


p命名空间注入
本质也是set注入,不过比直接set注入更方便.主要用于注入过多的时候.

首先引入p命名空间
```xml
<xmlns:p="http://www.springframework.org/schema/p">
```
也要修改注入方式
```xml
<bean id = "UserService" class = "com.service.UserService" p:userDao-ref = "userDao"/>
```

#### `Bean`的依赖注入的数据类型
前边都是注入引用的`Bean`,除了对象的引用可以注入,普通数据类型,集合等都可以在容器中进行注入.为什么要设定这种呢?因为有时候只需要对象的其中几个变量,无需全部注入.

注入数据的三种数据类型:
- 普通数据类型
- 引用数据类型
- 集合数据类型

普通数据类型:
```xml
<bean id="userDao" class="com.taytay.dao.impl.UserDaoImpl">
<property name="username" value="张三"/>
<property name="age" value="18"/>
</bean>
```
引用数据类型:
```XML

```




