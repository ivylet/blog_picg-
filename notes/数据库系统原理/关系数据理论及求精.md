### 问题提出

数据库模式设计好坏是数据库应用系统成败的关键,如何设计出"好"的模式呢?

#### 数据冗余导致的问题

##### 数据冗余:
同一信息在数据库中存储了多个副本

##### 可能导致的问题:

- 冗余存储: 信息被重复存储,导致浪费大量空间
- 更新异常: 重复信息的一个副本被修改后,所有副本都必须进行修改,不然会出现数据不一致的危险
- 插入异常: 只有当一些信息事先已经存放在数据库中时,另外一些信息才能存入数据库.
- 删除异常: 删除某些信息后可能会损失其他信息.

举例:
考虑到学生选课关系模式:
`SCE(studentNo, studentName, courseNo, courseName, score)`
其中属性集`{studentNo, courseNo}`是唯一候选码，也是主码。

如果允许一个学生选修多门课程，且一门课程可被多个学生选修，则该关系实例可能出现：
![[Pasted image 20220620200408.png]]

这种情况会出现以下问题:
- 冗余存储：学生姓名和课程名被重复存储多次；
- 更新异常：当修改某学生的姓名或某课程的课程名时，可能只修改了部分副本的信息，而其他副本未被修改到；
- 插入异常：如果某学生没有选修课程，或某课程未被任何学生选修时,则该学生或该课程信息不能存入数据库，因为主码值不能为空；
- 删除异常：当某学生的所有选修课程信息都被删除时，则该学生的信息将被丢失。对课程也是如此。

该实例所出现的问题是:

*部分函数依赖*
该模式中某些属性之间存在如下函数依赖关系
```sql
studentNo→studentName（即学号决定姓名）
courseNo→courseName（即课程编号决定课程名称）
{studentNo, courseNo}→score(即studentName、courseName部分依赖于关系的主码。)
```

解决方法
*关系模式分解*
分解为三个关系模式
S(studentNo, studentName)
C(courseNo, courseName)
E (studentNo, courseNo, score)

将一个有问题的关系模式分解为较小的关系模式集可以解决冗余问题,但是也有新问题,什么样的关系模式需要分解?是否都需要分解为较小的关系模式集.


#### 模式分解导致的问题

有些模式分解可能消除了冗余问题,但是会产生一些新的问题.例如信息丢失,依赖丢失等.这种问题主要是以下两种:
- 有损分解：两个分解后的关系通过连接运算还原得到的信息与原来关系的信息不一致。

如果能够通过连接分解后所得到的较小关系完全还原被分解关系的所有实例，称之为*无损分解(lossless decomposition)*，也称该分解具有无损连接特性。

- 丢失依赖关系:部分模式分解后,可能会导致不同模式之间的属性的依赖关系不再存在,从而导致丢失依赖关系.

如果被分解关系模式上的所有依赖关系都在分解得到的关系模式上保留，称该分解为*依赖保持 (dependency preserving)分解*。

一个"好"的关系模式应该是:
- 数据冗余尽可能少(即数据共享尽可能高)
- 不发生插入异常,删除异常,更新异常等问题.
- 模式分解时,分解后的模式应具有无损连接,保持依赖等特性.


### 函数依赖的定义

函数依赖(Functional Dependency, 简称FD)是一种完整性约束,  是现实世界事物属性之间的一种制约关系，它广泛地存在于现实世界之中。

#### 函数依赖

设r(R)为关系模式，aÍR，bÍR。对任意合法关系r及其中任两个元组ti和tj，i¹j，若ti[a]=tj[a]，则ti[b]=tj[b]，则称a函数确定b  ， 或  b 函数依赖于a，记作a®b。

对于函数依赖，需做如下说明：

- 函数依赖不是指关系模式r(R)的某个或某些关系实例满足的约束条件，而是指关系模式r(R)的所有关系实例均要满足的约束条件。
- 函数依赖是语义范畴的概念，只能根据数据的语义来确定函数依赖，是不能够被证明的。
- 数据库设计者可以对现实世界作强制的规定。
- 码约束是函数依赖的一个特例。码属性(集)相当于定义中的a，关系中的所有属性相当于定义的b。

#### 平凡与非平凡函数依赖

在关系模式r(R)中，aÍR，bÍR。若a®b，但bÍa，则称a®b是*非平凡函数依赖*。否则，若bÍa, 则称a®b是*平凡函数依赖*。

对于任一关系模式，平凡函数依赖都是必然成立的

#### 完全函数依赖和部分函数依赖

在关系模式r(R)中，aÍR，bÍR，且a®b是非平凡函数依赖。若对任意的gÌa，g®b都不成立，则称a®b 是完全函数依赖，简称*完全依赖*。否则，若存在非空的gÌa，使g®b 成立，则称a®b是部分函数依赖，简称*部分依赖*。

#### 传递函数依赖

在关系模式r(R)中，设a$\in$R，bÍR，gÍR，若a®b，b®g，则必存在函数依赖a®g；若a®b 、b®g和a®g都是非平凡函数依赖，且b®a，则称a®g是传递函数依赖，简称*传递依赖*。

#### 小结

函数依赖是指关系模式中属性之间存在的一种约束关系。这种约束关系既可以是现实世界事物或联系的属性之间客观存在的约束，也可以是数据库设计者根据应用需求或设计需要强加给数据的一种约束。

但不论是那种约束，一旦确定，进入数据库中的所有数据都必须严格遵守。

正确了解数据的意义及确定属性之间的函数依赖关系，对设计一个"好"的关系模式是十分重要的。

### 范式

#### 第一范式

如果一关系模式r(R)的每个属性对应的域值都是不可分的(即原子的)，则称r(R)属于第一范式，记为r(R)Î1NF.

第一范式的目标是：将基本数据划分成称为实体集或表的逻辑单元，当设计好每个实体后，需要为其指定主码。


#### 第二范式

设有一关系模式r(R)，aÍR。若a包含在r(R)的某个候选码中，则称a为主属性，否则a为非主属性。

如果一个关系模式r(R)Î1NF，且所有非主属性都完全函数依赖于r(R)的候选码，则称r(R)属于第二范式，记为r(R)Î2NF。

第二范式的目标：将只部分依赖于候选码（即依赖于候选码的部分属性）的非主属性移到其他表中。

#### 第三范式

如果一个关系模式r(R)Î2NF，且所有非主属性都直接函数依赖于r(R)的候选码（即不存在非主属性传递依赖于候选码），则称r(R)属于第三范式，记为r(R)Î3NF.

也就是说，在满足2NF的实体中，非主属性不能依赖于另一个非主属性（即非主属性只能直接依赖于候选码）

第三范式的目标：去掉表中不直接依赖于候选码的非主属性.

总之，所有的非主属性应该直接依赖于(即不能存在传递依赖，这是3NF的要求)全部的候选码(即必须完全依赖, 不能存在部分依赖，这是2NF的要求)。

#### 总结

数据冗余：冗余存储、更新异常、插入异常、删除异常。

“好”的关系模式应该是：

- 数据冗余应尽可能少；
- 不发生插入异常、删除异常、更新异常等问题；
- 模式分解时，需要满足无损连接、保持依赖等特性。

函数依赖、完全/部分函数依赖、传递/直接函数依赖。

范式：3NF Ì 2NF Ì 1NF。
2NF：所有非主属性都完全函数依赖于r(R)的候选码。
3NF：所有非主属性都直接函数依赖于r(R)的候选码。

#### Boyce-Codd范式



### 函数依赖理论

#### 函数依赖集闭包
#### 属性集闭包

### 模式分解算法

### 数据库模式求精