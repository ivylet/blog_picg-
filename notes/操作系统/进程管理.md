## PV算法


### 信号量机制
##### 概念
1. 整型信号量


2. 记录型信号量

```c
struct semaphore {
	int value;
	struct PCB *queue;
}semaphore;
```

```c
void wait(){
	S.value = S.value - 1;
	if S.value >= 0 本进程继续;
	else {
		将本进程放入阻塞态队列;
		转进程调度;
	}
}

void signal(){
	S.value = S.value + 1;
	if S.value ≤ 0 then 唤醒指针queue所指的阻塞态进程;
}
```

### 生产者-消费者问题
生产者生产后提供资源到缓冲区，消费者才可以从缓冲区取得资源。缓冲区的大小是有限的，并且生产者和消费者不能同时使用缓冲区。
#### 问题描述

#### 问题分析



### 读者-写者问题
对于一个文件F可以被多个并发进程共享，这些进程分为两类：一类是读进程，只能读取文件的内容；另一类进程为写进程，即对共享文件的更新(写)。显然多个读进程是可以同时进行，但是写进程不能和读进程同时进行，因为这样会导致读进程读取到错误信息。
#### 问题描述

#### 问题分析

`wmutex`:
`readcount`:
`rmutex`:

```c
void reader(){
	while(1){
		wait(rmutex);// 先来的判断一下能不能读
		if(readcout == 0)//如果是第一个读的进程，要看有没有写进程占用。
			wait(wmutex);//看看有没有写进程在写,没有就下一步.如果不是第一个读进程就不用看这一步，因为第一个读进程已经开始了，写进程不可能存在。
		readcount++;//确定写进程没有,就可以准备读了
		signal(rmutex);//确定能读,释放信号，让其他读进程也可以进入
		
		读操作:
		
		wait(rmutex);//读完后，先占用进程，修改readcount，如果不占用会导致错误。
		readcount--;//读取完毕
		if(readcount == 0)//如果恰好是最后一个读进程
			signal(wmutex);//那么就释放资源，让写进程可以进入。
		signal(rmutex);//修改完毕,读进程可以进入.
	}
}
```


### 哲学家进餐问题
设有五个哲学家在餐桌上吃饭，每个哲学家之间都有一支筷子，每支筷子同时只能让一个哲学家使用。每位哲学家拿够两支筷子才可以进餐，而且每位哲学家在未拿到两支筷子进餐前是不会放下自己手中的筷子的。所以问题怎么解决？
#### 问题描述
#### 问题分析