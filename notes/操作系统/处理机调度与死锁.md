
银行家算法  调度算法  一个应用题  一两个选择题 概念题 同样复习作业习题，作业未结合课后习题 都要看。废话
P104  3-9 可能考名词解释
P105  3-9 可能放选择题 
P106  3-17  出个类似？就是让你们知道，就怕你们不复习，就出作业题！


### 分级调度
1. 作业调度
	作业调度又称高级调度或长调度,用于选择把在外存上处于后备队列中的作业调入内存,并为其创建进程,分配必要的资源,然后将新创建的进程安排在就绪队列上,准备执行.
	批处理系统中,作业进入系统后先在外存,需要作业调度来分批装入内存.分时系统及实时系统为了做到及时响应,用户输入的命令是直接被送入内存的,因而无需配置作业调度机制.
2. 对换
	对换又称作交换调度或中级调度,主要是按照原则和策略,将处于外存交换区中的就绪或等待状态的进程调入内存,或把处于内存就绪状态或内存等待状态的进程交换到外存交换区.交换主要设计内存管理与扩充.
3. 进程调度
	进程调度又称作低级调度,主要是按照原则和策略,将处理机分配给一个处于就绪状态的进程.在确定了占用处理机的进程后,系统必须进行进程上下文切换以建立与占用处理机进程和适应的执行环境.
	1. 非抢占式   不允许进程抢占已经分配出去的处理机.开销小,实现简单,但是不能满足紧急任务的情况,可能会产生难以意料的情况.实时系统不宜采用这种方式.🧦
	2. 抢占式   允许调度程序根据某个正在执行的程序,将处理机回收,重新分配给另一个进程.

### 作业调度
#### 功能
1. 确定数据结构
2. 确定调度算法
3. 分配资源
4. 善后处理
#### 目标

提高系统的功能和效率

##### 面向系统的目标
1. 处理机以各类资源的利用率
2. 平衡性
3. 优先权准则
4. 公平性
##### 批处理系统的目标
1. 周转时间短
周转时间：从作业被提交给系统到作业终止为止到时间
带权周转时间：周转时间除以系统给予服务的时间(运行时间)。
2. 系统吞吐量高
吞吐量: 单位时间内系统完成的作业数
3. 处理机利用率高
##### 分时系统的目标
1. 响应时间快
2. 均衡性
##### 实时系统的目标
1. 截止时间的保证
2. 可预测性
### 进程调度
#### 进程调度的功能
##### 记录所有进程的执行情况
##### 从就绪状队列中选择一个进程
##### 进行进程上下文的切换
#### 进程调度的时机
1. 完成任务
2. 等待资源
3. 运行时间已到
#### 进程上下文的切换


### 调度算法
#### 先来先服务调度算法 FCFS

谁先来就先服务谁，该算法比较利于长作业或进程，而不利于短作业或进程

#### 短作业(进程)优先调度算法 SJF or SPF

谁短就先解决谁，如果 长度相同那么按照FCFS解决，即谁先来先解决谁，这种算法相比而言缩小了作业的平均周期和带权周转时，提高了性能。
但也有问题，算法对长作业不利，设想如果不断有短作业进入，那么长作业会被无限制延期而得不到调度；该算法未考虑作业的紧迫程度，不能保证紧迫作业的及时处理。

#### 高响应比优先调度算法 HRF or HRN

高响应比优先调度算法考虑的是作业等待时间长短而忽略作业的长短问题。

定义响应比R为已等待时间加要求服务时间的和除以要求服务的时间，即1+已等待时间除以要求服务的时间。每个进程加入后进行计算响应比，响应比高的先拿出来解决。以此可得短作业相比长作业会优先执行，但是长作业在等待足够时间后响应比也会变大从而得到及时解决。

该进程即照顾了短作业，也考虑到长作业的问题，但是每次调度前都要计算响应比，在一定程度上增大了系统开销。

#### 优先级调度算法 HPF

##### 优先级类型

1. 静态优先级
2. 动态优先级

##### 优先级调度算法的类型

1. 非抢占式优先级调度算法
	系统在就绪队列中选取优先级高的进程,分配给处理机,该进程一直执行下去,直到执行完毕或阻塞,才放弃该处理机.将处理机留给其他进程使用.
2. 抢占式优先级调度算法
	系统在就绪队列中选择优先级高的进程执行,分配给处理机,使之执行.执行期间如果出现了优先级更高的进程,该进程就会被终止.系统将处理机重新分配给优先级更高的进程.

#### 时间片轮转调度算法 RR

确定一个时间片段，将进程按照先入先出排序，每个队首进程在占用一个时间片段后终止，装入队尾，然后切换到下一个队首进程再执行一个时间片段.
这种调度算法主要是确定时间片段的大小，过小导致频繁的切换进程，从而导系统开销增大，过大足以进程在一个时间片段内完成又会变得和FCFS一样。

#### 多级队列调度算法 MLQ

该算法是FCFS，RR，HPF算法的综合。将进程按照优先级高低不同来分为二级或多级队列。进程调度时，首先从高优先级就绪队列中挑选进程，全部解决完毕后再从低优先级就绪队列中选取。每级队列调度算法可以按照FCFS，RR进行调度。按照RR算法时，不同队列的q值也可以不同。
这种算法的性能和实用性能好，而且容易实现，被流行的操作系统广泛使用。

#### 多级反馈队列调度算法 MLFQ

适合进程调度

和MLQ比较相像,不过加入了反馈机制。
(1)系统中设置多个就绪队列,各个队列具有不同的优先级.
(2)各就绪队列中进程的运行时间片不同,高优先级队列 的时间片小,低优先级队列的时间片大.
(3)一个新进程进入系统后,首先被放入第一队列的末尾,如某个进程在一次运行时没有完成工作,则把它转到下一级队列的末尾.
(4)系统先运行第一队列中的进程,第一队列为空后,才运行第二队列中的进程,依次类推.最后一个队列(最低优先级) 中的进程仍然采用时间片轮转的方式进行调度.
(5)当比运行进程更高级别的队列中有一个新进程时,它将抢占运行进程的处理机,而被抢占的进程回到原队列的末尾.
这种算法照顾了短作业,以及输入输出型进程




### 死锁

#### 死锁的概念

死锁是多个进程循环等待其他进程占有的资源,因而无限期僵持下去的局面.

举个例子：
进程P1现在占有资源R1，需要资源R2来进行下一步操作，而进程P2现在占有资源R2，需要资源R1来进行下一步操作，两者都在等待资源而不能继续运行。
死锁问题在没有外界的作用是会永远无限期推迟下去的。

#### 解决死锁的基本方法
1. 死锁的预防
2. 死锁的避免
3. 死锁的检测
4. 死锁的解除

#### 产生死锁的原因和必要条件
##### 产生死锁的原因
1. 各进程竞争有限的资源
2. 进程推进顺序不当

##### 死锁产生的必要条件
1. *互斥条件*  同一资源如果被某进程占用后,就不能被其他进程使用.
3. *占有且申请条件* 某进程占有一项资源但又要申请新的资源,在等待新的资源时不释放原有资源
4. *不可抢占条件*   进程的未使用并释放的资源不能被其他进程所使用.
5. *环路条件*   存在一个程序序列{P1,P2,P3,P4},P1等待P2占有的资源,P3等待P2占有的资源,P4等待P3占有的资源,P1等待P4占有的资源.



### 死锁的预防

#### 摒弃占有且申请条件
#### 摒弃不可抢占条件
#### 摒弃环路条件

### 死锁的避免

### 银行家算法-避免死锁🤫

#### 算法的数据结构

##### 可利用资源向量 Available

空闲向量，一个含有m个元素的向量，每一个元素代表对应的可用资源量，初始值为系统中所配置的所有资源数量，其中数值随着资源的分配与回收而动态的改变。

##### 最大需求矩阵 Max

定义为一个n ✖️ m的矩阵，定义了系统中n个进程中每个进程对m类资源的最大需求。

##### 分配矩阵 Allocation

占有矩阵，定义为一个n ✖️ m的矩阵，定义了系统中n个进程中每个进程对m类资源的占有情况。

##### 需求矩阵 Need

申请矩阵，定义为一个n ✖️ m的矩阵，定义了系统中n个进程中每个进程对m类资源的需求量。

显然有 Need[i,j] = Max[i,j] - Allocation[i,j]

#### 银行家算法的实现

##### 进程申请资源情况

##### 算法描述

##### 安全性算法

### 死锁的检测与解除

