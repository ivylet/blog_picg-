### 常用指令

#### vi编辑器
- 命令行指令
~~~
vi filename

~~~
- 编辑器内部命令行指令
~~~
:set nu   						显示行号
:w        						保存
:w newfilename 					另存为
:/word							查询单词word
:/word	n N				(n 向下寻找,N 向上寻找)	
i								插入
y								复制
p								粘贴
d								删除
w								切换到下一个单词
:wq								保存并退出
~~~


#### 文件管理指令

###### 删除操作

删除文件
- 单个文件
	`rm -f 文件名`
- 多个文件
	`rm -f *文件关键字*`
- 重命名文件/文件夹
	`mv (当前名称) (更改后名称)`



#### 使用gcc编译c程序
编写一个c程序 `program.c`
通过`gcc program.c`指令编译生成`a.out`文件
通过`./a.out`进行执行这个程序
后台执行 就在后边加`&`


### 管道通信
管道由Linux系统提供的pipe()函数创建，该函数原型为：
```c
#include<unistd.h>
int pipe(filedes[2]);
```

`pipe()` 函数用于在内核中创建一个通道,一端用于读取数据,另一端用于写入数据.创建完成后,会得到两个文件描述符,用于读取和写入

管道系统调用函数:
```c
wirte();

read();

close();

open();
```

##### 线程编程


### 进程间通信

Linux提供了管道通信,消息队列,信号量,套接字通信(网络通信)

#### 为什么需要进程间通信?
- 数据传输

#### 管道通信
管道通信是单向的,先进先出的.将一个进程的输出与另一个进程的输出连接到一起.在一个进程(写进程)的尾部写入数据,另一个进程(读进程)的头部读出数据.

数据被进程读出后,将从管道中删除,其他进程不能在读取数据/管道提供了简单的流控制机制,进程试图读取空管道时,进程将堵塞.

- 无名管道
	- 创建
		- 无名管道由创建
	- 管道关闭
		- 关闭管道只需将这两个文件描述符关闭即可.也可以使用普通的close函数逐个关闭.
	- 使用特点
		- 只能用于具有亲缘关系的进程间通信(如父子进程)
		- 工作方式为半双工
	- 使用功能
		- 常用于
	- 注意事项
		- 可以通过打开两个管道来创建一个双向的管道.但需要在子进程中正确地设置文件描述符.
		- 必须在系统调用`fork()`前调用`pipe()`,否则子进程将不会继承 #文件描述符.

- 命名管道FIFO
	- 错误信息

- 信号
	- 定义
	信号是软中断,可以作为进程间通信的一种机制
	- 的
	- 信号的来源 

#### 信号量
#### 共享内存
#### 消息队列


### 存储器管理概述
#### 存储器结构层次
#### 存储层次结构部分
|层次结构|主要组成|
|---|---|
|第一层次|寄存器<br> 高速缓冲存储器|
|第二层次|内存<br>磁盘缓存|
|第三层次|磁盘<br>可移动存储介质|

层次越高,价格越高,访问速度越快,存储容量越低.

寄存器.高速缓冲存储器,内存,磁盘缓存都属于操作系统存储管理范围,不可长久保存数据.

磁盘,可移动存储介质属于操作系统设备管理范围,可以长久保存数据.

1. 寄存器
	访问速度最快,但是价格最昂贵,容量小,通常以字节为单位.用于加速存储访问的速度.如用于存放操作数,用作地址寄存器或变址寄存器,以加快地址变换速度等.	
2. 高速缓冲存储器
	由硬件寄存器构成,存取速度相当快
3. 内存
	内存又称作主存,用于存放进程运行时的程序和数据
4. 磁盘缓存
	磁盘的输入输出

#### 用户程序的处理过程😉

1. 系统对用户程序的处理过程
	系统对用户程序的处理分为以下几个阶段:
	1. 编译.
		由编译程序将用户源代码编译成若干个目标模块.
	2. 链接
		由链接程序将编译后形成的目标代码以及它们所需的库函数链接在一起,形成一个装入模块
	3. 装入
		由装入程序将装入模块装入内存
2. 目标程序装入内存的方式
1. 

##### 存储空间及重定位
#### 分区存储管理
##### 单道程序的连续分配
##### 固定分区分配方式
##### 动态分区分配
##### 可重定位分区
#### 页式存储管理
##### 页式存储管理思想
##### 页式存储管理的数据结构
##### 页式存储管理的重定位
##### 快表
##### 两级和多级页表
#### 段式存储管理
##### 段式存储管理思想
##### 段页式存储管理
#### 虚拟存储器
##### 局部性原理
##### 对换
##### 覆盖
##### 虚拟存储器
#### 请求分页内存管理
##### 请求分页的实现
##### 内存分配
#### 页面置换算法
##### 先进先出页面置换算法
##### 最近最久未使用页面置换算法
##### 最佳置换算法
##### 时钟置换算法
##### 抖动与工作集
#### 请求分段存储管理
##### 请求分段的原理和硬件支持
##### 段的共享与保护
##### 段的共享与保护的实现
#### Linux系统的内存管理方法
##### Linux分页管理机制
##### 虚存段的组织与管理
##### 内存的共享和保护
##### 内存空间管理
##### 空闲内存管理
##### 内核态内存的申请与释放
##### 用户态内存的申请和释放
##### 交换空间
##### 页交换进程和页面换出
##### 缺页中断和页面换入



##### 物理内存

系统硬件提供的内存大小.

##### 虚拟内存

利用磁盘空间

1. 内存查看工具
	1. free命令
	2. vmstat命令
2. 虚拟文件系统proc
	1. /proc/meminfo目录下

关于main的参数

- main(int argc,char \*argc[],char \*envp[])

##### 概念：

###### 虚拟内存(Virtual Memory)：
首先需要强调的是虚拟内存不同于物理内存，虽然两者都包含内存字眼但是它们属于两个不同层面的概念。进程占用虚拟内存空间大并非意味着程序的物理内存也一定占用很大。

虚拟内存是操作系统内核为了对进程地址空间进行管理(process address space management)而精心设计的一个逻辑意义上的内存空间概念。我们程序中的指针其实都是这个虚拟内存空间中的地址。比如我们在写完一段C程序之后都需要采用gcc进行编译，这时候编译器采用的地址其实就是虚拟内存空间的地址。因为这时候程序还没有运行,何谈物理内存空间地址?凡是程序运行过程中可能需要用到的指令或者数据都必须在虚拟内存空间中.既然说虚拟内存是一个逻辑意义上(假象的)的内存空间,为了能够让程序在物理机器上运行，那么必须有一套机制可以让这些假象的虚拟内存空间映射到物理内存空间(实实在在的RAM内存条上的空间)。这其实就是操作系统中页映射表(page table)所做的事情了。内核会为系统中每一个进程维护一份相互独立的页映射表。

虚拟内存是一个假象的内存空间，在程序运行过程中虚拟内存空间中需要被访问的部分会被映射到物理内存空间中。虚拟内存空间大只能表示程序运行过程中可访问的空间比较大，不代表物理内存空间占用也大。

###### 驻留内存(Resident Memory)：
驻留内存，顾名思义是指那些被映射到进程虚拟内存空间的物理内存。进程的驻留内存就是进程实实在在占用的物理内存。一般我们所讲的进程占用了多少内存，其实就是说的占用了多少驻留内存而不是多少虚拟内存。因为虚拟内存大并不意味着占用的物理内存大。

##### bss段 

bss segment

通常是指用来存放程序中未初始化的全局变量的一块内存区域。
bss是英文Block Started by Symbol的简称。
bss段属于静态内存分配。

##### data段 

data segment
　
通常是指用来存放程序中已初始化的全局变量的一块内存区域。
数据段属于静态内存分配。

##### heap(堆)段 

堆是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。

当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；
当利用free等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）。

##### text段 

code segment/text segment

通常是指用来存放程序执行代码的一块内存区域。
这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读(某些架构也允许代码段为可写，即允许修改程序)。
在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等。

##### stack(展)段

栈又称堆栈，是用户存放程序临时创建的局部变量，
也就是说我们函数括弧“{}”中定义的变量(但不包括static声明的变量，static意味着在数据段中存放变量)。
除此以外，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。
由于栈的先进先出(FIFO)特点，所以栈特别方便用来保存/恢复调用现场。
从这个意义上讲，我们可以把堆栈看成一个寄存、交换临时数据的内存区。

#### 虚拟内存具体布局
- TEXT段：存放代码；
- DATA段：存放已经初始化的全局变量和static变量；
- BSS段：存放未初始化的全局变量和static变量；
- HEAP：堆，动态内存分配区，堆在进程地址空间中是自低地址向高地址增长；
- STACK：栈，函数参数传递、局部变量等都放在栈中，栈由高地址向低地址增长。
- 代码段、数据段和BSS段长度在程序编译之后确定。而HEAP和STACK栈随着程序的运行动态变化。


|名称|地址|映像文件|
|---|---|---|
|程序的代码段|557448a44000-557447f11000|vm_mem|
|程序的数据段|7fad4b3d2000-7fad4b5ed000|x86_64-linux-gnu/libc.so.6|
|程序的堆段|557448a44000-557448a65000|heap|
|程序的栈段|7ffc6d492000-7ffc6d4b3000|stack|

### Linux多线程
#### 两个进程函数

- `fork()` 函数
	在 LINUX 系统创建一个新进程的唯一方法是使用`fork()`函数.
	- 函数说明
	`fork()`函数用于在一个已知进程中创建一个新进程,新进程被称为子进程,原进程为父进程.自进程继承了父进程整个进程的地址空间,包括进程的上下文、代码段、进程堆栈、内存信息、打开的文件描述符、符号控制设定、进程优先级、进程组号、当前工作目录、根目录、资源限制和控制终端等.子进程相比而言独有的是进程号,资源使用和计时器等.
	父进程的`fork()`函数返回的是创建的子进程的pid值,而子进程执行的`fork()`函数返回的值是0,可以通过这个来区分子进程与父进程.
	`fork()`函数复制了父进程的大部分内容,使得系统开销很大,而且执行速度也不快.
	
	| 所需头文件 | \#include<sys/types.h>/\*提供类型pid\*/</br>\#include<unistd.h> |
	| --- | --- |
	| 函数原型 | pid_t fork(void)  |
	| 函数返回值 | 0:子进程</br>子进程PID(大于0的整数:父进程</br>-1:出错|

- `exec()` 函数
	按照我的理解是,终止当前进程的所有内容,运行选择的进程的内容
	- 函数说明
### Linux多进程编程
#### 逻辑流与并发流
##### 并发
##### 逻辑控制流
##### 并发流及相关概念

##### 并发与并行
#### 进程基本概念
##### 进程概念、结构与描述
##### 什么是进程
##### 进程结构
###### 进程属性(保存在PCB中)
进程描述信息
进程控制信息
进程资源信息


进程状态
就绪
阻塞
运行
进程
双向链表+树形结构
树形结构为父子关系，父节点为父进程，子节点位子进程，用p_pptr
进程实例
#### 操作进程工具
ps命令查看进程信息
$ps -ef
$pfs-ef|bash here
ps -u
ps l显示当前用户拥有的进程信息
kill 终止进程
命令后加 & 使进程在后台进行
`get_pid`

