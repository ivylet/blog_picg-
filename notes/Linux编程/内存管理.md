
### 存储器管理概述
#### 存储器结构层次
#### 存储层次结构部分
|层次结构|主要组成|
|---|---|
|第一层次|寄存器<br> 高速缓冲存储器|
|第二层次|内存<br>磁盘缓存|
|第三层次|磁盘<br>可移动存储介质|

层次越高,价格越高,访问速度越快,存储容量越低.

寄存器.高速缓冲存储器,内存,磁盘缓存都属于操作系统存储管理范围,不可长久保存数据.

磁盘,可移动存储介质属于操作系统设备管理范围,可以长久保存数据.

1. 寄存器
	访问速度最快,但是价格最昂贵,容量小,通常以字节为单位.用于加速存储访问的速度.如用于存放操作数,用作地址寄存器或变址寄存器,以加快地址变换速度等.	
2. 高速缓冲存储器
	由硬件寄存器构成,存取速度相当快
3. 内存
	内存又称作主存,用于存放进程运行时的程序和数据
4. 磁盘缓存
	磁盘的输入输出

#### 用户程序的处理过程😉

1. 系统对用户程序的处理过程
	系统对用户程序的处理分为以下几个阶段:
	1. 编译.
		由编译程序将用户源代码编译成若干个目标模块.
	2. 链接
		由链接程序将编译后形成的目标代码以及它们所需的库函数链接在一起,形成一个装入模块
	3. 装入
		由装入程序将装入模块装入内存
2. 目标程序装入内存的方式
1. 

#### 存储空间及重定位
### 分区存储管理
#### 单道程序的连续分配
#### 固定分区分配方式
#### 动态分区分配
#### 可重定位分区
### 页式存储管理
#### 页式存储管理思想
#### 页式存储管理的数据结构
#### 页式存储管理的重定位
#### 快表
#### 两级和多级页表
### 段式存储管理
#### 段式存储管理思想
#### 段页式存储管理
### 虚拟存储器
#### 局部性原理
#### 对换
#### 覆盖
#### 虚拟存储器
### 请求分页内存管理
#### 请求分页的实现
#### 内存分配
### 页面置换算法
#### 先进先出页面置换算法
#### 最近最久未使用页面置换算法
#### 最佳置换算法
#### 时钟置换算法
#### 抖动与工作集
### 请求分段存储管理
#### 请求分段的原理和硬件支持
#### 段的共享与保护
#### 段的共享与保护的实现
### Linux系统的内存管理方法
#### Linux分页管理机制
#### 虚存段的组织与管理
#### 内存的共享和保护
#### 内存空间管理
#### 空闲内存管理
#### 内核态内存的申请与释放
#### 用户态内存的申请和释放
#### 交换空间
#### 页交换进程和页面换出
#### 缺页中断和页面换入



##### 物理内存

系统硬件提供的内存大小.

##### 虚拟内存

利用磁盘空间

1. 内存查看工具
	1. free命令
	2. vmstat命令
2. 虚拟文件系统proc
	1. /proc/meminfo目录下

关于main的参数

- main(int argc,char \*argc[],char \*envp[])

##### 概念：

###### 虚拟内存(Virtual Memory)：
首先需要强调的是虚拟内存不同于物理内存，虽然两者都包含内存字眼但是它们属于两个不同层面的概念。进程占用虚拟内存空间大并非意味着程序的物理内存也一定占用很大。

虚拟内存是操作系统内核为了对进程地址空间进行管理(process address space management)而精心设计的一个逻辑意义上的内存空间概念。我们程序中的指针其实都是这个虚拟内存空间中的地址。比如我们在写完一段C程序之后都需要采用gcc进行编译，这时候编译器采用的地址其实就是虚拟内存空间的地址。因为这时候程序还没有运行,何谈物理内存空间地址?凡是程序运行过程中可能需要用到的指令或者数据都必须在虚拟内存空间中.既然说虚拟内存是一个逻辑意义上(假象的)的内存空间,为了能够让程序在物理机器上运行，那么必须有一套机制可以让这些假象的虚拟内存空间映射到物理内存空间(实实在在的RAM内存条上的空间)。这其实就是操作系统中页映射表(page table)所做的事情了。内核会为系统中每一个进程维护一份相互独立的页映射表。

虚拟内存是一个假象的内存空间，在程序运行过程中虚拟内存空间中需要被访问的部分会被映射到物理内存空间中。虚拟内存空间大只能表示程序运行过程中可访问的空间比较大，不代表物理内存空间占用也大。

###### 驻留内存(Resident Memory)：
驻留内存，顾名思义是指那些被映射到进程虚拟内存空间的物理内存。进程的驻留内存就是进程实实在在占用的物理内存。一般我们所讲的进程占用了多少内存，其实就是说的占用了多少驻留内存而不是多少虚拟内存。因为虚拟内存大并不意味着占用的物理内存大。

##### bss段 

bss segment

通常是指用来存放程序中未初始化的全局变量的一块内存区域。
bss是英文Block Started by Symbol的简称。
bss段属于静态内存分配。

##### data段 

data segment
　
通常是指用来存放程序中已初始化的全局变量的一块内存区域。
数据段属于静态内存分配。

##### heap(堆)段 

堆是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。

当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；
当利用free等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）。

##### text段 

code segment/text segment

通常是指用来存放程序执行代码的一块内存区域。
这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读(某些架构也允许代码段为可写，即允许修改程序)。
在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等。

##### stack(展)段

栈又称堆栈，是用户存放程序临时创建的局部变量，
也就是说我们函数括弧“{}”中定义的变量(但不包括static声明的变量，static意味着在数据段中存放变量)。
除此以外，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。
由于栈的先进先出(FIFO)特点，所以栈特别方便用来保存/恢复调用现场。
从这个意义上讲，我们可以把堆栈看成一个寄存、交换临时数据的内存区。

#### 虚拟内存具体布局
- TEXT段：存放代码；
- DATA段：存放已经初始化的全局变量和static变量；
- BSS段：存放未初始化的全局变量和static变量；
- HEAP：堆，动态内存分配区，堆在进程地址空间中是自低地址向高地址增长；
- STACK：栈，函数参数传递、局部变量等都放在栈中，栈由高地址向低地址增长。
- 代码段、数据段和BSS段长度在程序编译之后确定。而HEAP和STACK栈随着程序的运行动态变化。


|名称|地址|映像文件|
|---|---|---|
|程序的代码段|557448a44000-557447f11000|vm_mem|
|程序的数据段|7fad4b3d2000-7fad4b5ed000|x86_64-linux-gnu/libc.so.6|
|程序的堆段|557448a44000-557448a65000|heap|
|程序的栈段|7ffc6d492000-7ffc6d4b3000|stack|

